/*
 * Licensed under the LICENSE.
 * Copyright 2017, Sony Mobile Communications Inc.
 */

/*
 * A simple project management server which illustrates
 * how configuring and executing a job works within GComp
 */

var runningFromCmd = require.main === module;

//Dependencies
var https = require("https");
var fs = require("fs");
var zlib = require('zlib');
var x509 = require('x509');

var resPath = __dirname + '/';

var consolelog = function(string){
  if (runningFromCmd)
    console.log(string);
};

var consoledir = function(string){
  if (runningFromCmd)
    console.dir(string);
};


//Configuration
var jobserver = {

  //Job server address
  address: "localhost",

  //Job server port
  postPort: 1337,
  statusPort: 1336,

  //The CA used to identify the job server.
  ca: [fs.readFileSync(resPath + 'jobserver-cacert.pem').toString()]
};

var pmserver = {
  key: fs.readFileSync(resPath + 'pmserver-key.pem').toString(),
  cert: fs.readFileSync(resPath + 'pmserver-cert.pem').toString(),
  ca: fs.readFileSync(resPath + 'pmserver-cacert.pem').toString()
};

var pmclient = {
  //The client private key generated by us
  key: fs.readFileSync(resPath + 'pmclient-key.pem').toString(),

  //The client certificate generated by us
  cert: fs.readFileSync(resPath + 'pmclient-cert.pem').toString(),
};

var subject = x509.getSubject(pmserver.cert);
consolelog(subject);
var attributes = JSON.parse(subject['1.2.3.4.5']);

var serveraddress = attributes.server_address;
var serverport = attributes.server_port;

//Number of jobs to execute in this test setup.
var job_count = 1;

//Timeout handler lists that will be populated for each job.
var startupTimeouts = {};
var completionTimeouts = {};

//A list of completed jobs.
var completedJobs = {count:0};

//The result received from each job.
var jobResults = {};
var restartHandler = null;
var toRestart = [];

//Add more jobs automatically
var checkQueueLenght = function() {
  reqOptions = {
    //Server details
    host: jobserver.address,
    port: jobserver.statusPort,
    path: '/status',
    method: 'GET',

    agent: false,
    rejectUnauthorized: false
  };

  var req = https.request(reqOptions, function(res) {
    if (res.statusCode != 200) {
      consolelog('statusCode: ' + res.statusCode);
    } else {
      var data = '';
      res.on('data', function(chunk) {
        data += chunk;
      });

      res.on('end', function() {
        data = JSON.parse(data);
        var queue = data.queue_length;
        var s_queue = data.secure_queue_length;


        consolelog('length queue: ' + queue);
        consolelog('length s_queue: ' + s_queue);
        if (queue === undefined || queue < 2)
        startJobs(1000, false, null);

      if (s_queue === undefined || s_queue < 2)
        startJobs(1000, true, null);

      //Check every 10minutes
      setTimeout(checkQueueLenght, 1000 * 600);
      });

    }
  });

  req.on('error', function(err) {
    consoledir(err);
  });

  req.end();

}

var startJobs = function(jc, secure, callback){
  data = {
    path: "/script",

    //Key to login and download scripts from this server.
    client_key: pmclient.key,

    //Certificate for job downloads.
    client_cert: pmclient.cert,

    //The number of jobs that will be executed with these parameters.
    //This variable will be added to your URI.
    job_count: jc,

    //The job can run on an insecure device
    secure: secure
  };

  data = JSON.stringify(data);
  var opts = {
    host: jobserver.address,
    port: jobserver.postPort,

    //The jobserver CA
    //TODO: With a CA-signed certificate, this is not necessary.
    ca: jobserver.ca,

    //Our provided identity on the job server.
    key: pmserver.key,
    cert: pmserver.cert,

    rejectUnauthorized: true,

    path: "/job",
    method: "POST",
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'Content-Length': data.length
    },
    agent:false
  };
  var req = https.request(opts, function(res) {
    if(res.statusCode != 200){
      consolelog("Error adding job to queue. Status code " + res.statusCode);
    }

    var data = "";
    res.on('data', function(chunk){
      data += chunk;
    });
    res.on('end', function(){
      consolelog("Added jobs to server queue.");
      var estimationTime;
      try {
        estimationTime = JSON.parse(data).job_exec_est_time;
      } catch(e) {
        estimationTime = 0;
      }
      consolelog("Estimation time of job execution: " + estimationTime + " seconds");
      if (callback) {
        callback();
      };
    });
  });
  req.on('error', function(err){
    consolelog("Error adding job to queue");
    callback(err);
  });
  req.write(data);
  req.end();
}

//Handle incoming connections from jobs.
var f = new (require("events").EventEmitter)();

var server = https.createServer({

  //The ID for this server as signed by the job server.
  key: pmserver.key,
    cert: pmserver.cert,

    //Demand the client successfully logs in to the PM server.
    requestCert: true,
    rejectUnauthorized: true,

    //Since it is self signed, we use the own certificate.
    ca: pmclient.cert,

}, function(req,res){
  var q = require("url").parse(req.url, true);
  if(!f.emit(q.pathname, q, res, req)){
    res.writeHead(404);
    res.end();
  }
});

server.on("error", function(err){
  console.dir(err);
});

function sendJob(res, data, encoding) {
  if (encoding.match(/\bgzip\b/)) {
    res.writeHead(200, 'OK', {'Content-Encoding': 'gzip' });
    zlib.gzip(data, function(err, decoded) {
      if (!err) {
        res.write(decoded);
        res.end();
      } else {
        res.writeHead(500);
        res.end();
      }
    });
  } else {
    res.writeHead(200, 'OK', {'Content-Type': 'text/plain; charset=\"utf8\"'});
    res.write(data);
    res.end();
  }
}

//Called by the node client to download the script from us.
f.on('/script', function(q, res, req){
  consolelog("script called");
  var jobscript = fs.readFileSync(resPath + "cljobscript.js", 'utf8');
  var encoding = req.headers['accept-encoding'];

  if (!encoding)
  encoding = '';
sendJob(res, jobscript, encoding);
addJob();
});

//A message we've set up the job to send us when it's done.
f.on('/done', function(q, res, req){
  consolelog("called done");

  req.on('data', function(d){
    consolelog(d.toString());
  });

  req.on('end', function(d){

    //If we're not sending any response, just end the connection ASAP.
    res.writeHead(200);
    res.end();

    consolelog("Job finished!");
  });
});

function start() {
  server.listen(serverport);
}

function close() {
  server.close();
}

function addJob(callback) {
  startJobs(job_count, false, callback);
}

if (runningFromCmd) {
  start();
  checkQueueLenght();
}

module.exports = {
  start: start,
  close: close,
  addJob: addJob
};
